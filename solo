from warnings import filterwarnings
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import geopy as gps

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import Dense, Activation, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import Accuracy
import matplotlib.pyplot as plt

API_KEY = "AkvYaDkG40h_rbg-DIGhsap7cxZic5v4GUlAWqeAMkZ1prAuXXx_TLRUGCrb-Uiv"  # Replace with your Bing Maps API key

geolocator = gps.geocoders.Bing('AkvYaDkG40h_rbg-DIGhsap7cxZic5v4GUlAWqeAMkZ1prAuXXx_TLRUGCrb-Uiv')



dataset = pd.read_csv('realtor-data.zip.csv')
dataset2= pd.read_csv('test.csv')


a = input("what is your monthley income ")
b= input("type of property required (enter the no of beds required)")
c=12*int(a)
print(c)
X= dataset.iloc[:, 1:].values
y = dataset.iloc [:,2:3].values
z=dataset.iloc[:,1].values
dataset.drop("status",axis=1,inplace=True)
dataset.drop("city",axis=1,inplace=True)
dataset.drop("state",axis=1,inplace=True)

from sklearn.impute import SimpleImputer

imputer = SimpleImputer(strategy="mean")
y= imputer.fit_transform(y)

for c in dataset.iloc[:,2:3].values:
  if(c<=z.all()):
    from sklearn.cluster import KMeans
    wcss = []
    for i in range(1, 11):
      kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)
      kmeans.fit(y)
      wcss.append(kmeans.inertia_)
  if (b==y.all()):
      from sklearn.cluster import KMeans
      wcss = []
      for i in range(1, 11):
        kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)
        kmeans.fit(y)
        wcss.append(kmeans.inertia_)
        kmeans = KMeans(n_clusters = 5, init = 'k-means++', random_state = 42)
        m = kmeans.fit_predict(y)
      predictions = kmeans.predict(y)
      print(y[predictions == 0])

yt=input('if property is already selected and not in the given list.put the amount of the poperty :')
d=input('enter the preffered propetry amount: ')
k=input('the loan amount required: ')
e=input('enter your gender: ')
g=input('enter your no of dependents : ')
f=input('no of working indivisuals : ')
h=input('total household income : ')

i={e,g,f,h,k}

j=dataset2.iloc[:, 7:11]
o = dataset2.iloc[:, :-1].values
p = dataset2.iloc[:, -1].values

q=input('tenure of loan amount(no of years) : ')
    




from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.model_selection import train_test_split

j_train, j_test, o_train, o_test = train_test_split(j, o, test_size=0.1)

sc = StandardScaler()
j_train = sc.fit_transform(j_train)
j_test = sc.transform(j_test)

j_train.shape, j_test.shape, o_train.shape, o_test.shape



from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.model_selection import train_test_split



sc = StandardScaler()


ann_model = keras.Sequential()

# adding dense layer
ann_model.add(Dense(250, input_dim=13, kernel_initializer='normal', activation='relu'))
ann_model.add(Dropout(0.3))
ann_model.add(Dense(500, activation='relu'))
ann_model.add(Dropout(0.3))
ann_model.add(Dense(500, activation='relu'))
ann_model.add(Dropout(0.3))
ann_model.add(Dense(500, activation='relu'))
ann_model.add(Dropout(0.4))
ann_model.add(Dense(250, activation='linear'))
ann_model.add(Dropout(0.4))

# adding dense layer with softmax activation/output layer
ann_model.add(Dense(2, activation='softmax'))
ann_model.summary()


from keras import backend as K

def recall_m(o_true, o_pred):
    true_positives = K.sum(K.round(K.clip(o_true * o_pred, 0, 1)))
    possible_positives = K.sum(K.round(K.clip(o_true, 0, 1)))
    recall = true_positives / (possible_positives + K.epsilon())
    return recall

def precision_m(o_true, o_pred):
    true_positives = K.sum(K.round(K.clip(o_true * o_pred, 0, 1)))
    predicted_positives = K.sum(K.round(K.clip(o_pred, 0, 1)))
    precision = true_positives / (predicted_positives + K.epsilon())
    return precision

def f1_m(o_true, o_pred):
    precision = precision_m(o_true, o_pred)
    recall = recall_m(o_true, o_pred)
    return 2*((precision*recall)/(precision+recall+K.epsilon()))

from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
ct1 = ColumnTransformer(transformers=[('Male', OneHotEncoder(), [0])], remainder='passthrough')
n = np.array(ct1.fit_transform(o))
ct2 = ColumnTransformer(transformers=[('Female', OneHotEncoder(), [1])], remainder='passthrough')
n = np.array(ct2.fit_transform(o))

tf.convert_to_tensor(o)
predictions = ann_model.predict(o)
predict = []

for i in predictions:
    predict.append(np.argmax(i))


from sklearn import metrics
o= np.argmax(o.astype(str), axis=0).astype(str)

f1 = metrics.f1_score(o, predict)
prec = metrics.precision_score(o, predict)
rec = metrics.recall_score(o, predict)
acc = metrics.accuracy_score(o, predict)

print ("F1 Score: {:.4f}.".format(f1))
print ("Precision: {:.4f}.".format(prec))
print ("Recall: {:.4f}.".format(rec))
print ("Accuracy: {:.4f}.".format(acc))
