import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import geopy as gps

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import Dense, Activation, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import Accuracy
import matplotlib.pyplot as plt

API_KEY = "AkvYaDkG40h_rbg-DIGhsap7cxZic5v4GUlAWqeAMkZ1prAuXXx_TLRUGCrb-Uiv"  # Replace with your Bing Maps API key

geolocator = gps.geocoders.Bing('AkvYaDkG40h_rbg-DIGhsap7cxZic5v4GUlAWqeAMkZ1prAuXXx_TLRUGCrb-Uiv')



dataset = pd.read_csv('realtor-data.zip.csv')
dataset2= pd.read_csv('test.csv')



a = input("what is your monthley income ")
b= input ("type of property required (enter the no of beds required)")
c=12*int(a)
print(c)
X= dataset.iloc[:, 1:].values
y = dataset.iloc [:,1].values
z=dataset.iloc[:,1].values


for c in dataset.iloc[2:3,1].values:
  if(c<=z.all()):
    from sklearn.cluster import KMeans
    wcss = []
    for i in range(1, 90877):
      kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)
    kmeans.fit(X)
    wcss.append(kmeans.inertia_)
  if (int(b)==y.all()):
       from sklearn.cluster import KMeans
       wcss = []
       for i in range(1, 90877):
        kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)
        kmeans.fit(X)
        wcss.append(kmeans.inertia_)
        kmeans = KMeans(n_clusters = 5, init = 'k-means++', random_state = 42)
        m=kmeans.fit_predict(X)
        plt.scatter(X[ m== 0, 0], X[m==0, 1], s = 100, c = 'red', label = 'Cluster 1')
        plt.scatter(X[m== 1, 0], X[m== 1, 1], s = 100, c = 'blue', label = 'Cluster 2')
        plt.scatter(X[ m==2, 0], X[m== 2, 1], s = 100, c = 'green', label = 'Cluster 3')
        plt.scatter(X[ m==3, 0], X[m==3, 1], s = 100, c = 'cyan', label = 'Cluster 4')

d=input('enter the preffered propetry amount: ')
e=input('enter your gender: ')
g=input('enter your no of dependents : ')
f=input('no of working indivisuals : ')
h=input('total household income : ')
k=input('the loan amount required: ')
i={e,g,f,h,k}

j=dataset2.iloc[:, 11]
o = dataset2.iloc[:, :-1].values
p = dataset2.iloc[:, -1].values

q=input('tenure of loan amount(no of years) : ')

bank_df = pd.read_csv(".csv")



from tensorflow.keras.utils import to_categorical

X = bank_df.drop(columns=[""])
y = bank_df["Personal Loan"]

y = to_categorical(y)

from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)

sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

X_train.shape, X_test.shape, y_train.shape, y_test.shape



from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.model_selection import train_test_split



sc = StandardScaler()


ann_model = keras.Sequential()

# adding dense layer
ann_model.add(Dense(250, input_dim=13, kernel_initializer='normal', activation='relu'))
ann_model.add(Dropout(0.3))
ann_model.add(Dense(500, activation='relu'))
ann_model.add(Dropout(0.3))
ann_model.add(Dense(500, activation='relu'))
ann_model.add(Dropout(0.3))
ann_model.add(Dense(500, activation='relu'))
ann_model.add(Dropout(0.4))
ann_model.add(Dense(250, activation='linear'))
ann_model.add(Dropout(0.4))

# adding dense layer with softmax activation/output layer
ann_model.add(Dense(2, activation='softmax'))
ann_model.summary()


from keras import backend as K

def recall_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
    recall = true_positives / (possible_positives + K.epsilon())
    return recall

def precision_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
    precision = true_positives / (predicted_positives + K.epsilon())
    return precision

def f1_m(y_true, y_pred):
    precision = precision_m(y_true, y_pred)
    recall = recall_m(y_true, y_pred)
    return 2*((precision*recall)/(precision+recall+K.epsilon()))
y = y.reshape((y.shape[0], 1))

predictions = ann_model.predict(y)
predict = []

for i in predictions:
    predict.append(np.argmax(i))


from sklearn import metrics
o= np.argmax(o.astype(str), axis=0).astype(str)

f1 = metrics.f1_score(o, predict)
prec = metrics.precision_score(o, predict)
rec = metrics.recall_score(o, predict)
acc = metrics.accuracy_score(o, predict)

print ("F1 Score: {:.4f}.".format(f1))
print ("Precision: {:.4f}.".format(prec))
print ("Recall: {:.4f}.".format(rec))
print ("Accuracy: {:.4f}.".format(acc))
